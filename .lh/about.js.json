{
    "sourceFile": "about.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1703136438222,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1703136462941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-export default About {\r\n+export default About() {\r\n     document.addEventListener(\"DOMContentLoaded\", function () {\r\n         runningLogos();\r\n     });\r\n \r\n"
                },
                {
                    "date": 1703136482907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,128 +1,126 @@\n-export default About() {\r\n-    document.addEventListener(\"DOMContentLoaded\", function () {\r\n-        runningLogos();\r\n-    });\r\n+document.addEventListener(\"DOMContentLoaded\", function () {\r\n+  runningLogos();\r\n+});\r\n \r\n-    function runningLogos() {\r\n-        const logoWrappers = gsap.utils.toArray(\".partner__logo-w\");\r\n-        const sliderSpeedInSec = 5;\r\n-        const speeds = [0.4, 0.5, 1];\r\n+function runningLogos() {\r\n+  const logoWrappers = gsap.utils.toArray(\".partner__logo-w\");\r\n+  const sliderSpeedInSec = 5;\r\n+  const speeds = [0.4, 0.5, 1];\r\n \r\n-        logoWrappers.forEach((logoWrapper, i) => {\r\n-            logoItems = gsap.utils.toArray(logoWrappers[i].children);\r\n-            console.log(logoItems);\r\n-            const speed = speeds[i];\r\n-            const isEvenRow = i % 2 === 0;\r\n+  logoWrappers.forEach((logoWrapper, i) => {\r\n+    logoItems = gsap.utils.toArray(logoWrappers[i].children);\r\n+    console.log(logoItems);\r\n+    const speed = speeds[i];\r\n+    const isEvenRow = i % 2 === 0;\r\n \r\n-            horizontalLoop(logoItems, {\r\n-                paused: false,\r\n-                repeat: -1,\r\n-                speed: speed,\r\n-                paddingRight: 40,\r\n-                reversed: !isEvenRow\r\n-            });\r\n-        });\r\n+    horizontalLoop(logoItems, {\r\n+      paused: false,\r\n+      repeat: -1,\r\n+      speed: speed,\r\n+      paddingRight: 40,\r\n+      reversed: !isEvenRow\r\n+    });\r\n+  });\r\n+}\r\n+\r\n+function horizontalLoop(items, config) {\r\n+  items = gsap.utils.toArray(items);\r\n+  config = config || {};\r\n+  let tl = gsap.timeline({\r\n+      repeat: config.repeat,\r\n+      paused: config.paused,\r\n+      defaults: { ease: \"none\" },\r\n+      onReverseComplete: () => tl.totalTime(tl.rawTime() + tl.duration() * 100)\r\n+    }),\r\n+    length = items.length,\r\n+    startX = items[0].offsetLeft,\r\n+    times = [],\r\n+    widths = [],\r\n+    xPercents = [],\r\n+    curIndex = 0,\r\n+    pixelsPerSecond = (config.speed || 1) * 100,\r\n+    snap = config.snap === false ? (v) => v : gsap.utils.snap(config.snap || 1),\r\n+    totalWidth,\r\n+    curX,\r\n+    distanceToStart,\r\n+    distanceToLoop,\r\n+    item,\r\n+    i;\r\n+  gsap.set(items, {\r\n+    // convert \"x\" to \"xPercent\" to make things responsive, and populate the widths/xPercents Arrays to make lookups faster.\r\n+    xPercent: (i, el) => {\r\n+      let w = (widths[i] = parseFloat(gsap.getProperty(el, \"width\", \"px\")));\r\n+      xPercents[i] = snap(\r\n+        (parseFloat(gsap.getProperty(el, \"x\", \"px\")) / w) * 100 +\r\n+          gsap.getProperty(el, \"xPercent\")\r\n+      );\r\n+      return xPercents[i];\r\n     }\r\n-\r\n-    function horizontalLoop(items, config) {\r\n-        items = gsap.utils.toArray(items);\r\n-        config = config || {};\r\n-        let tl = gsap.timeline({\r\n-            repeat: config.repeat,\r\n-            paused: config.paused,\r\n-            defaults: { ease: \"none\" },\r\n-            onReverseComplete: () => tl.totalTime(tl.rawTime() + tl.duration() * 100)\r\n-        }),\r\n-        length = items.length,\r\n-        startX = items[0].offsetLeft,\r\n-        times = [],\r\n-        widths = [],\r\n-        xPercents = [],\r\n-        curIndex = 0,\r\n-        pixelsPerSecond = (config.speed || 1) * 100,\r\n-        snap = config.snap === false ? (v) => v : gsap.utils.snap(config.snap || 1),\r\n-        totalWidth,\r\n-        curX,\r\n-        distanceToStart,\r\n-        distanceToLoop,\r\n+  });\r\n+  gsap.set(items, { x: 0 });\r\n+  totalWidth =\r\n+    items[length - 1].offsetLeft +\r\n+    (xPercents[length - 1] / 100) * widths[length - 1] -\r\n+    startX +\r\n+    items[length - 1].offsetWidth *\r\n+      gsap.getProperty(items[length - 1], \"scaleX\") +\r\n+    (parseFloat(config.paddingRight) || 0);\r\n+  for (i = 0; i < length; i++) {\r\n+    item = items[i];\r\n+    curX = (xPercents[i] / 100) * widths[i];\r\n+    distanceToStart = item.offsetLeft + curX - startX;\r\n+    distanceToLoop =\r\n+      distanceToStart + widths[i] * gsap.getProperty(item, \"scaleX\");\r\n+    tl.to(\r\n+      item,\r\n+      {\r\n+        xPercent: snap(((curX - distanceToLoop) / widths[i]) * 100),\r\n+        duration: distanceToLoop / pixelsPerSecond\r\n+      },\r\n+      0\r\n+    )\r\n+      .fromTo(\r\n         item,\r\n-        i;\r\n-        gsap.set(items, {\r\n-            // convert \"x\" to \"xPercent\" to make things responsive, and populate the widths/xPercents Arrays to make lookups faster.\r\n-            xPercent: (i, el) => {\r\n-                let w = (widths[i] = parseFloat(gsap.getProperty(el, \"width\", \"px\")));\r\n-                xPercents[i] = snap(\r\n-                    (parseFloat(gsap.getProperty(el, \"x\", \"px\")) / w) * 100 +\r\n-                        gsap.getProperty(el, \"xPercent\")\r\n-                );\r\n-                return xPercents[i];\r\n-            }\r\n-        });\r\n-        gsap.set(items, { x: 0 });\r\n-        totalWidth =\r\n-            items[length - 1].offsetLeft +\r\n-                (xPercents[length - 1] / 100) * widths[length - 1] -\r\n-                startX +\r\n-                items[length - 1].offsetWidth *\r\n-                    gsap.getProperty(items[length - 1], \"scaleX\") +\r\n-                (parseFloat(config.paddingRight) || 0);\r\n-        for (i = 0; i < length; i++) {\r\n-            item = items[i];\r\n-            curX = (xPercents[i] / 100) * widths[i];\r\n-            distanceToStart = item.offsetLeft + curX - startX;\r\n-            distanceToLoop =\r\n-                distanceToStart + widths[i] * gsap.getProperty(item, \"scaleX\");\r\n-            tl.to(\r\n-                item,\r\n-                {\r\n-                    xPercent: snap(((curX - distanceToLoop) / widths[i]) * 100),\r\n-                    duration: distanceToLoop / pixelsPerSecond\r\n-                },\r\n-                0\r\n-            )\r\n-                .fromTo(\r\n-                    item,\r\n-                    {\r\n-                        xPercent: snap(\r\n-                            ((curX - distanceToLoop + totalWidth) / widths[i]) * 100\r\n-                        )\r\n-                    },\r\n-                    {\r\n-                        xPercent: xPercents[i],\r\n-                        duration:\r\n-                        (curX - distanceToLoop + totalWidth - curX) / pixelsPerSecond,\r\n-                        immediateRender: false\r\n-                    },\r\n-                    distanceToLoop / pixelsPerSecond\r\n-                )\r\n-                .add(\"label\" + i, distanceToStart / pixelsPerSecond);\r\n-            times[i] = distanceToStart / pixelsPerSecond;\r\n-        }\r\n-        function toIndex(index, vars) {\r\n-            vars = vars || {};\r\n-            Math.abs(index - curIndex) > length / 2 &&\r\n-                (index += index > curIndex ? -length : length); // always go in the shortest direction\r\n-            let newIndex = gsap.utils.wrap(0, length, index),\r\n-            time = times[newIndex];\r\n-            if (time > tl.time() !== index > curIndex) {\r\n-                // if we're wrapping the timeline's playhead, make the proper adjustments\r\n-                vars.modifiers = { time: gsap.utils.wrap(0, tl.duration()) };\r\n-                time += tl.duration() * (index > curIndex ? 1 : -1);\r\n-            }\r\n-            curIndex = newIndex;\r\n-            vars.overwrite = true;\r\n-            return tl.tweenTo(time, vars);\r\n-        }\r\n-        tl.next = (vars) => toIndex(curIndex + 1, vars);\r\n-        tl.previous = (vars) => toIndex(curIndex - 1, vars);\r\n-        tl.current = () => curIndex;\r\n-        tl.toIndex = (index, vars) => toIndex(index, vars);\r\n-        tl.times = times;\r\n-        tl.progress(1, true).progress(0, true); // pre-render for performance\r\n-        if (config.reversed) {\r\n-            tl.vars.onReverseComplete();\r\n-            tl.reverse();\r\n-        }\r\n-        return tl;\r\n+        {\r\n+          xPercent: snap(\r\n+            ((curX - distanceToLoop + totalWidth) / widths[i]) * 100\r\n+          )\r\n+        },\r\n+        {\r\n+          xPercent: xPercents[i],\r\n+          duration:\r\n+            (curX - distanceToLoop + totalWidth - curX) / pixelsPerSecond,\r\n+          immediateRender: false\r\n+        },\r\n+        distanceToLoop / pixelsPerSecond\r\n+      )\r\n+      .add(\"label\" + i, distanceToStart / pixelsPerSecond);\r\n+    times[i] = distanceToStart / pixelsPerSecond;\r\n+  }\r\n+  function toIndex(index, vars) {\r\n+    vars = vars || {};\r\n+    Math.abs(index - curIndex) > length / 2 &&\r\n+      (index += index > curIndex ? -length : length); // always go in the shortest direction\r\n+    let newIndex = gsap.utils.wrap(0, length, index),\r\n+      time = times[newIndex];\r\n+    if (time > tl.time() !== index > curIndex) {\r\n+      // if we're wrapping the timeline's playhead, make the proper adjustments\r\n+      vars.modifiers = { time: gsap.utils.wrap(0, tl.duration()) };\r\n+      time += tl.duration() * (index > curIndex ? 1 : -1);\r\n     }\r\n+    curIndex = newIndex;\r\n+    vars.overwrite = true;\r\n+    return tl.tweenTo(time, vars);\r\n+  }\r\n+  tl.next = (vars) => toIndex(curIndex + 1, vars);\r\n+  tl.previous = (vars) => toIndex(curIndex - 1, vars);\r\n+  tl.current = () => curIndex;\r\n+  tl.toIndex = (index, vars) => toIndex(index, vars);\r\n+  tl.times = times;\r\n+  tl.progress(1, true).progress(0, true); // pre-render for performance\r\n+  if (config.reversed) {\r\n+    tl.vars.onReverseComplete();\r\n+    tl.reverse();\r\n+  }\r\n+  return tl;\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1703136508742,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,5 @@\n+export default function About(){\r\n document.addEventListener('DOMContentLoaded', function () {\r\n   runningLogos()\r\n })\r\n \r\n@@ -114,4 +115,5 @@\n     tl.reverse()\r\n   }\r\n   return tl\r\n }\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1703136651561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,7 @@\n export default function About() {\r\n+    console.log('about')\r\n+    \r\n   document.addEventListener('DOMContentLoaded', function () {\r\n     runningLogos()\r\n   })\r\n \r\n"
                }
            ],
            "date": 1703136438222,
            "name": "Commit-0",
            "content": "export default About {\r\n    document.addEventListener(\"DOMContentLoaded\", function () {\r\n        runningLogos();\r\n    });\r\n\r\n    function runningLogos() {\r\n        const logoWrappers = gsap.utils.toArray(\".partner__logo-w\");\r\n        const sliderSpeedInSec = 5;\r\n        const speeds = [0.4, 0.5, 1];\r\n\r\n        logoWrappers.forEach((logoWrapper, i) => {\r\n            logoItems = gsap.utils.toArray(logoWrappers[i].children);\r\n            console.log(logoItems);\r\n            const speed = speeds[i];\r\n            const isEvenRow = i % 2 === 0;\r\n\r\n            horizontalLoop(logoItems, {\r\n                paused: false,\r\n                repeat: -1,\r\n                speed: speed,\r\n                paddingRight: 40,\r\n                reversed: !isEvenRow\r\n            });\r\n        });\r\n    }\r\n\r\n    function horizontalLoop(items, config) {\r\n        items = gsap.utils.toArray(items);\r\n        config = config || {};\r\n        let tl = gsap.timeline({\r\n            repeat: config.repeat,\r\n            paused: config.paused,\r\n            defaults: { ease: \"none\" },\r\n            onReverseComplete: () => tl.totalTime(tl.rawTime() + tl.duration() * 100)\r\n        }),\r\n        length = items.length,\r\n        startX = items[0].offsetLeft,\r\n        times = [],\r\n        widths = [],\r\n        xPercents = [],\r\n        curIndex = 0,\r\n        pixelsPerSecond = (config.speed || 1) * 100,\r\n        snap = config.snap === false ? (v) => v : gsap.utils.snap(config.snap || 1),\r\n        totalWidth,\r\n        curX,\r\n        distanceToStart,\r\n        distanceToLoop,\r\n        item,\r\n        i;\r\n        gsap.set(items, {\r\n            // convert \"x\" to \"xPercent\" to make things responsive, and populate the widths/xPercents Arrays to make lookups faster.\r\n            xPercent: (i, el) => {\r\n                let w = (widths[i] = parseFloat(gsap.getProperty(el, \"width\", \"px\")));\r\n                xPercents[i] = snap(\r\n                    (parseFloat(gsap.getProperty(el, \"x\", \"px\")) / w) * 100 +\r\n                        gsap.getProperty(el, \"xPercent\")\r\n                );\r\n                return xPercents[i];\r\n            }\r\n        });\r\n        gsap.set(items, { x: 0 });\r\n        totalWidth =\r\n            items[length - 1].offsetLeft +\r\n                (xPercents[length - 1] / 100) * widths[length - 1] -\r\n                startX +\r\n                items[length - 1].offsetWidth *\r\n                    gsap.getProperty(items[length - 1], \"scaleX\") +\r\n                (parseFloat(config.paddingRight) || 0);\r\n        for (i = 0; i < length; i++) {\r\n            item = items[i];\r\n            curX = (xPercents[i] / 100) * widths[i];\r\n            distanceToStart = item.offsetLeft + curX - startX;\r\n            distanceToLoop =\r\n                distanceToStart + widths[i] * gsap.getProperty(item, \"scaleX\");\r\n            tl.to(\r\n                item,\r\n                {\r\n                    xPercent: snap(((curX - distanceToLoop) / widths[i]) * 100),\r\n                    duration: distanceToLoop / pixelsPerSecond\r\n                },\r\n                0\r\n            )\r\n                .fromTo(\r\n                    item,\r\n                    {\r\n                        xPercent: snap(\r\n                            ((curX - distanceToLoop + totalWidth) / widths[i]) * 100\r\n                        )\r\n                    },\r\n                    {\r\n                        xPercent: xPercents[i],\r\n                        duration:\r\n                        (curX - distanceToLoop + totalWidth - curX) / pixelsPerSecond,\r\n                        immediateRender: false\r\n                    },\r\n                    distanceToLoop / pixelsPerSecond\r\n                )\r\n                .add(\"label\" + i, distanceToStart / pixelsPerSecond);\r\n            times[i] = distanceToStart / pixelsPerSecond;\r\n        }\r\n        function toIndex(index, vars) {\r\n            vars = vars || {};\r\n            Math.abs(index - curIndex) > length / 2 &&\r\n                (index += index > curIndex ? -length : length); // always go in the shortest direction\r\n            let newIndex = gsap.utils.wrap(0, length, index),\r\n            time = times[newIndex];\r\n            if (time > tl.time() !== index > curIndex) {\r\n                // if we're wrapping the timeline's playhead, make the proper adjustments\r\n                vars.modifiers = { time: gsap.utils.wrap(0, tl.duration()) };\r\n                time += tl.duration() * (index > curIndex ? 1 : -1);\r\n            }\r\n            curIndex = newIndex;\r\n            vars.overwrite = true;\r\n            return tl.tweenTo(time, vars);\r\n        }\r\n        tl.next = (vars) => toIndex(curIndex + 1, vars);\r\n        tl.previous = (vars) => toIndex(curIndex - 1, vars);\r\n        tl.current = () => curIndex;\r\n        tl.toIndex = (index, vars) => toIndex(index, vars);\r\n        tl.times = times;\r\n        tl.progress(1, true).progress(0, true); // pre-render for performance\r\n        if (config.reversed) {\r\n            tl.vars.onReverseComplete();\r\n            tl.reverse();\r\n        }\r\n        return tl;\r\n    }\r\n}"
        }
    ]
}