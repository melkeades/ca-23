{
    "sourceFile": "utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1703945965396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1703945979820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,40 +156,5 @@\n   observer.observe(element, {\r\n     attributes: true,\r\n     attributeFilter: ['class'],\r\n   })\r\n-}\r\n-\r\n-// Define a function that takes an element, an array of class names, and a callback function as arguments\r\n-function observeClasses(element, classNames, callback) {\r\n-  // Create a mutation observer that will monitor the element's attributes and subtree\r\n-  var observer = new MutationObserver(function (mutations) {\r\n-    // Loop through the mutations\r\n-    for (var mutation of mutations) {\r\n-      // Check if the mutation is related to the class attribute\r\n-      if (mutation.attributeName === 'class') {\r\n-        // Check if the element or any of its children contains all of the class names\r\n-        if (element.matches(classNames.join('.')) || element.querySelector(classNames.join('.'))) {\r\n-          // If yes, disconnect the observer\r\n-          observer.disconnect()\r\n-          // And call the callback function\r\n-          callback()\r\n-        }\r\n-      }\r\n-    }\r\n-  })\r\n-\r\n-  // Start observing the element's attributes and subtree\r\n-  observer.observe(element, { attributes: true, subtree: true })\r\n-}\r\n-\r\n-// Example usage\r\n-// Get an element by its id\r\n-var div = document.getElementById('myDiv')\r\n-// Define an array of class names\r\n-var classes = ['myClass1', 'myClass2']\r\n-// Define a callback function that will log a message\r\n-var callback = function () {\r\n-  console.log('The element or its child has the classes!')\r\n-}\r\n-// Call the observeClasses function with the element, the array of class names, and the callback function\r\n-observeClasses(div, classes, callback)\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1704293459885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,178 @@\n+export const sel = (e) => document.querySelector(e)\r\n+export const selAll = (e) => document.querySelectorAll(e)\r\n+export const vh = (percent) => window.innerHeight * (percent / 100)\r\n+export const vw = (percent) => window.innerWidth * (percent / 100)\r\n+\r\n+export function debounce(func, time = 100) {\r\n+  let timer\r\n+  return function (event) {\r\n+    if (timer) clearTimeout(timer)\r\n+    timer = setTimeout(func, time, event)\r\n+  }\r\n+}\r\n+export function devMode(mode) {\r\n+  if (mode === 0) {\r\n+    return\r\n+  } else if (mode === 1) {\r\n+    let i = 0\r\n+    document.querySelectorAll('[data-video-urls]').forEach((el) => {\r\n+      el.querySelector('video').remove()\r\n+      i++\r\n+    })\r\n+    console.log('devMode, removed videos:', i)\r\n+  } else if (mode === 2) {\r\n+    const devRemoveList = []\r\n+    // const devRemoveList = [videoHero$, introSec$, aboutSec$]\r\n+    devRemoveList.forEach((el) => {\r\n+      el.remove()\r\n+    })\r\n+    console.log('devMode: removing sections')\r\n+  }\r\n+}\r\n+\r\n+export function removeSplideClasses(slider) {\r\n+  const splide = document.querySelector('.' + slider)\r\n+  const track = splide.querySelector('.splide__track')\r\n+  const list = splide.querySelector('.splide__list')\r\n+  const slide = splide.querySelectorAll('.splide__slide')\r\n+  splide.classList.remove('splide')\r\n+  track.classList.remove('splide__track')\r\n+  list.classList.remove('splide__list')\r\n+  slide.forEach((slide) => slide.classList.remove('splide__slide'))\r\n+}\r\n+export function addSplideClasses(slider) {\r\n+  const splide = document.querySelector('.' + slider)\r\n+  const track = splide.children[0]\r\n+  const list = track.children[0]\r\n+  const slide = list.childNodes\r\n+  splide.classList.add('splide')\r\n+  track.classList.add('splide__track')\r\n+  list.classList.add('splide__list')\r\n+  slide.forEach((slide) => slide.classList.add('splide__slide'))\r\n+}\r\n+\r\n+export function connectSplideArrows(splide, classPrefix) {\r\n+  sel(`.${classPrefix}__arrows .arrow--left`).addEventListener('pointerdown', function () {\r\n+    splide.go('<')\r\n+  })\r\n+\r\n+  sel(`.${classPrefix}__arrows .arrow:not(.arrow--left)`).addEventListener('pointerdown', function () {\r\n+    splide.go('>')\r\n+  })\r\n+}\r\n+export function connectSplideBullets(splide, classPrefix) {\r\n+  // parse bullets inside the container and repopulate\r\n+  const pagination$ = sel(`.${classPrefix}__pagination`)\r\n+  let bulletPressed = false\r\n+  if (splide.length > 1) {\r\n+    const bullet$ = sel(`.${classPrefix}__pagination .bullet:not(.bullet--active)`)\r\n+    let fragment = document.createDocumentFragment()\r\n+    for (let i = 0; i < splide.length; i++) {\r\n+      let clone$ = bullet$.cloneNode(true)\r\n+      clone$.addEventListener('click', (e) => {\r\n+        bulletPressed = true\r\n+        splide.go(i)\r\n+      })\r\n+      fragment.appendChild(clone$)\r\n+    }\r\n+    fragment.firstChild.classList.add('bullet--active')\r\n+    pagination$.replaceChildren(fragment)\r\n+  } else {\r\n+    pagination$.replaceChildren()\r\n+  }\r\n+  splide.on('move', function (newIndex, oldIndex) {\r\n+    sel(`.${classPrefix}__pagination .bullet--active`).classList.remove('bullet--active')\r\n+    sel(`.${classPrefix}__pagination .bullet:nth-of-type(${splide.index + 1})`).classList.add('bullet--active')\r\n+  })\r\n+}\r\n+\r\n+export function splideAutoWidth(splide) {\r\n+  // if not enough logos it will center them and stop the slider\r\n+  const Components = splide.Components\r\n+  // to remove duplicates for inactive/small slider\r\n+  splide.on('overflow', function (isOverflow) {\r\n+    splide.go(0) // Reset the carousel position\r\n+\r\n+    splide.options = {\r\n+      focus: isOverflow ? 'center' : '',\r\n+      drag: isOverflow ? 'free' : false,\r\n+      clones: isOverflow ? undefined : 0, // Toggle clones\r\n+    }\r\n+  })\r\n+  let sliderOverflow = true\r\n+  let sliderReady = false\r\n+  // to center inactive/small slider\r\n+  splide.on('resized', function () {\r\n+    var isOverflow = Components.Layout.isOverflow()\r\n+    sliderOverflow = isOverflow\r\n+    var list = Components.Elements.list\r\n+    var lastSlide = Components.Slides.getAt(splide.length - 1)\r\n+\r\n+    if (lastSlide) {\r\n+      // Toggles `justify-content: center`\r\n+      list.style.justifyContent = isOverflow ? '' : 'center'\r\n+\r\n+      // Remove the last margin\r\n+      if (!isOverflow) {\r\n+        lastSlide.slide.style.marginRight = ''\r\n+      }\r\n+    }\r\n+    if (sliderReady) {\r\n+      splideInit()\r\n+    }\r\n+  })\r\n+  splide.on('mounted', splideInit)\r\n+  function splideInit() {\r\n+    sliderReady = true\r\n+    if (!sliderOverflow) {\r\n+      splide.Components.AutoScroll.pause()\r\n+    } else if (sliderOverflow && splide.Components.AutoScroll.isPaused()) {\r\n+      // } else if (sliderOverflow && splide.Components.AutoScroll?.isPaused()) {\r\n+      splide.Components.AutoScroll.play()\r\n+    }\r\n+  }\r\n+}\r\n+\r\n+export function onDomReady(run) {\r\n+  if (document.readyState !== 'loading') {\r\n+    run()\r\n+  } else {\r\n+    document.addEventListener('DOMContentLoaded', function () {\r\n+      run()\r\n+    })\r\n+  }\r\n+}\r\n+\r\n+// Add an observer that checks if a class exists. If it does remove the observer and call a function\r\n+export function addObserver(element, className, callback) {\r\n+  const observer = new MutationObserver(function (mutations) {\r\n+    mutations.forEach(function (mutation) {\r\n+      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\r\n+        observer.disconnect()\r\n+        callback()\r\n+      }\r\n+    })\r\n+  })\r\n+  observer.observe(element, {\r\n+    attributes: true,\r\n+    attributeFilter: ['class'],\r\n+  })\r\n+}\r\n+\r\n+import gsap from 'gsap'\r\n+import { ScrollTrigger } from 'gsap/ScrollTrigger'\r\n+\r\n+export function scrollTriggerInit(distance = 0, elClassName = '', sectionClassName = '') {\r\n+  gsap.registerPlugin(ScrollTrigger)\r\n+\r\n+  sectionClassName = sectionClassName || elClassName\r\n+  return ScrollTrigger.create({\r\n+    animation: gsap.fromTo('.' + elClassName, { y: -distance }, { y: distance, ease: 'none' }),\r\n+    trigger: '.' + sectionClassName,\r\n+    start: 'top bottom',\r\n+    end: 'bottom top',\r\n+    // markers: true,\r\n+    scrub: true,\r\n+    delay: 0.0,\r\n+  })\r\n+}\r\n"
                }
            ],
            "date": 1703945965396,
            "name": "Commit-0",
            "content": "export const sel = (e) => document.querySelector(e)\r\nexport const selAll = (e) => document.querySelectorAll(e)\r\nexport const vh = (percent) => window.innerHeight * (percent / 100)\r\nexport const vw = (percent) => window.innerWidth * (percent / 100)\r\n\r\nexport function debounce(func, time = 100) {\r\n  let timer\r\n  return function (event) {\r\n    if (timer) clearTimeout(timer)\r\n    timer = setTimeout(func, time, event)\r\n  }\r\n}\r\nexport function devMode(mode) {\r\n  if (mode === 0) {\r\n    return\r\n  } else if (mode === 1) {\r\n    let i = 0\r\n    document.querySelectorAll('[data-video-urls]').forEach((el) => {\r\n      el.querySelector('video').remove()\r\n      i++\r\n    })\r\n    console.log('devMode, removed videos:', i)\r\n  } else if (mode === 2) {\r\n    const devRemoveList = []\r\n    // const devRemoveList = [videoHero$, introSec$, aboutSec$]\r\n    devRemoveList.forEach((el) => {\r\n      el.remove()\r\n    })\r\n    console.log('devMode: removing sections')\r\n  }\r\n}\r\n\r\nexport function removeSplideClasses(slider) {\r\n  const splide = document.querySelector('.' + slider)\r\n  const track = splide.querySelector('.splide__track')\r\n  const list = splide.querySelector('.splide__list')\r\n  const slide = splide.querySelectorAll('.splide__slide')\r\n  splide.classList.remove('splide')\r\n  track.classList.remove('splide__track')\r\n  list.classList.remove('splide__list')\r\n  slide.forEach((slide) => slide.classList.remove('splide__slide'))\r\n}\r\nexport function addSplideClasses(slider) {\r\n  const splide = document.querySelector('.' + slider)\r\n  const track = splide.children[0]\r\n  const list = track.children[0]\r\n  const slide = list.childNodes\r\n  splide.classList.add('splide')\r\n  track.classList.add('splide__track')\r\n  list.classList.add('splide__list')\r\n  slide.forEach((slide) => slide.classList.add('splide__slide'))\r\n}\r\n\r\nexport function connectSplideArrows(splide, classPrefix) {\r\n  sel(`.${classPrefix}__arrows .arrow--left`).addEventListener('pointerdown', function () {\r\n    splide.go('<')\r\n  })\r\n\r\n  sel(`.${classPrefix}__arrows .arrow:not(.arrow--left)`).addEventListener('pointerdown', function () {\r\n    splide.go('>')\r\n  })\r\n}\r\nexport function connectSplideBullets(splide, classPrefix) {\r\n  // parse bullets inside the container and repopulate\r\n  const pagination$ = sel(`.${classPrefix}__pagination`)\r\n  let bulletPressed = false\r\n  if (splide.length > 1) {\r\n    const bullet$ = sel(`.${classPrefix}__pagination .bullet:not(.bullet--active)`)\r\n    let fragment = document.createDocumentFragment()\r\n    for (let i = 0; i < splide.length; i++) {\r\n      let clone$ = bullet$.cloneNode(true)\r\n      clone$.addEventListener('click', (e) => {\r\n        bulletPressed = true\r\n        splide.go(i)\r\n      })\r\n      fragment.appendChild(clone$)\r\n    }\r\n    fragment.firstChild.classList.add('bullet--active')\r\n    pagination$.replaceChildren(fragment)\r\n  } else {\r\n    pagination$.replaceChildren()\r\n  }\r\n  splide.on('move', function (newIndex, oldIndex) {\r\n    sel(`.${classPrefix}__pagination .bullet--active`).classList.remove('bullet--active')\r\n    sel(`.${classPrefix}__pagination .bullet:nth-of-type(${splide.index + 1})`).classList.add('bullet--active')\r\n  })\r\n}\r\n\r\nexport function splideAutoWidth(splide) {\r\n  // if not enough logos it will center them and stop the slider\r\n  const Components = splide.Components\r\n  // to remove duplicates for inactive/small slider\r\n  splide.on('overflow', function (isOverflow) {\r\n    splide.go(0) // Reset the carousel position\r\n\r\n    splide.options = {\r\n      focus: isOverflow ? 'center' : '',\r\n      drag: isOverflow ? 'free' : false,\r\n      clones: isOverflow ? undefined : 0, // Toggle clones\r\n    }\r\n  })\r\n  let sliderOverflow = true\r\n  let sliderReady = false\r\n  // to center inactive/small slider\r\n  splide.on('resized', function () {\r\n    var isOverflow = Components.Layout.isOverflow()\r\n    sliderOverflow = isOverflow\r\n    var list = Components.Elements.list\r\n    var lastSlide = Components.Slides.getAt(splide.length - 1)\r\n\r\n    if (lastSlide) {\r\n      // Toggles `justify-content: center`\r\n      list.style.justifyContent = isOverflow ? '' : 'center'\r\n\r\n      // Remove the last margin\r\n      if (!isOverflow) {\r\n        lastSlide.slide.style.marginRight = ''\r\n      }\r\n    }\r\n    if (sliderReady) {\r\n      s2PlayInit()\r\n    }\r\n  })\r\n  splide.on('mounted', s2PlayInit)\r\n  function s2PlayInit() {\r\n    sliderReady = true\r\n    if (!sliderOverflow) {\r\n      splide.Components.AutoScroll.pause()\r\n    } else if (sliderOverflow && splide.Components.AutoScroll.isPaused()) {\r\n      // } else if (sliderOverflow && splide.Components.AutoScroll?.isPaused()) {\r\n      splide.Components.AutoScroll.play()\r\n    }\r\n  }\r\n}\r\n\r\nexport function onDomReady(run) {\r\n  if (document.readyState !== 'loading') {\r\n    run()\r\n  } else {\r\n    document.addEventListener('DOMContentLoaded', function () {\r\n      run()\r\n    })\r\n  }\r\n}\r\n\r\n// Add an observer that checks if a class exists. If it does remove the observer and call a function\r\nexport function addObserver(element, className, callback) {\r\n  const observer = new MutationObserver(function (mutations) {\r\n    mutations.forEach(function (mutation) {\r\n      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\r\n        observer.disconnect()\r\n        callback()\r\n      }\r\n    })\r\n  })\r\n  observer.observe(element, {\r\n    attributes: true,\r\n    attributeFilter: ['class'],\r\n  })\r\n}\r\n\r\n\r\n// Define a function that takes an element, an array of class names, and a callback function as arguments\r\nfunction observeClasses(element, classNames, callback) {\r\n// Create a mutation observer that will monitor the element's attributes and subtree\r\nvar observer = new MutationObserver(function(mutations) {\r\n// Loop through the mutations\r\nfor (var mutation of mutations) {\r\n// Check if the mutation is related to the class attribute\r\nif (mutation.attributeName === \"class\") {\r\n// Check if the element or any of its children contains all of the class names\r\nif (element.matches(classNames.join(\".\")) || element.querySelector(classNames.join(\".\"))) {\r\n// If yes, disconnect the observer\r\nobserver.disconnect();\r\n// And call the callback function\r\ncallback();\r\n}\r\n}\r\n}\r\n});\r\n\r\n// Start observing the element's attributes and subtree\r\nobserver.observe(element, { attributes: true, subtree: true });\r\n}\r\n\r\n// Example usage\r\n// Get an element by its id\r\nvar div = document.getElementById(\"myDiv\");\r\n// Define an array of class names\r\nvar classes = [\"myClass1\", \"myClass2\"];\r\n// Define a callback function that will log a message\r\nvar callback = function() {\r\nconsole.log(\"The element or its child has the classes!\");\r\n};\r\n// Call the observeClasses function with the element, the array of class names, and the callback function\r\nobserveClasses(div, classes, callback);\r\n"
        }
    ]
}